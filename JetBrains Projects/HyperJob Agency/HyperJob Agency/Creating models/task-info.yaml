type: edu
custom_name: stage1
files:
- name: vacancy/migrations/__init__.py
  visible: true
  learner_created: false
- name: vacancy/__init__.py
  visible: true
  learner_created: false
- name: hyperjob/urls.py
  visible: true
  text: |
    """hyperjob URL Configuration

    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/2.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.contrib import admin
    from django.urls import path

    urlpatterns = [
        path('admin/', admin.site.urls),
    ]
  learner_created: false
- name: hyperjob/wsgi.py
  visible: true
  text: |
    """
    WSGI config for hyperjob project.

    It exposes the WSGI callable as a module-level variable named ``application``.

    For more information on this file, see
    https://docs.djangoproject.com/en/2.2/howto/deployment/wsgi/
    """

    import os

    from django.core.wsgi import get_wsgi_application

    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'hyperjob.settings')

    application = get_wsgi_application()
  learner_created: false
- name: hyperjob/__init__.py
  visible: true
  learner_created: false
- name: hyperjob/settings.py
  visible: true
  text: |
    """
    Django settings for hyperjob project.

    Generated by 'django-admin startproject' using Django 2.2.6.

    For more information on this file, see
    https://docs.djangoproject.com/en/2.2/topics/settings/

    For the full list of settings and their values, see
    https://docs.djangoproject.com/en/2.2/ref/settings/
    """

    import os

    # Build paths inside the project like this: os.path.join(BASE_DIR, ...)
    BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))


    # Quick-start development settings - unsuitable for production
    # See https://docs.djangoproject.com/en/2.2/howto/deployment/checklist/

    # SECURITY WARNING: keep the secret key used in production secret!
    SECRET_KEY = '*57#^8!%%x4wi6byh%qj3!&7b)qu5ve7m5tz9&)2^jievj2j1b'

    # SECURITY WARNING: don't run with debug turned on in production!
    DEBUG = True

    ALLOWED_HOSTS = []


    # Application definition

    INSTALLED_APPS = [
        'django.contrib.admin',
        'django.contrib.auth',
        'django.contrib.contenttypes',
        'django.contrib.sessions',
        'django.contrib.messages',
        'django.contrib.staticfiles',
        'resume',
        'vacancy',
    ]

    MIDDLEWARE = [
        'django.middleware.security.SecurityMiddleware',
        'django.contrib.sessions.middleware.SessionMiddleware',
        'django.middleware.common.CommonMiddleware',
        'django.middleware.csrf.CsrfViewMiddleware',
        'django.contrib.auth.middleware.AuthenticationMiddleware',
        'django.contrib.messages.middleware.MessageMiddleware',
        'django.middleware.clickjacking.XFrameOptionsMiddleware',
    ]

    ROOT_URLCONF = 'hyperjob.urls'

    TEMPLATES = [
        {
            'BACKEND': 'django.template.backends.django.DjangoTemplates',
            'DIRS': [],
            'APP_DIRS': True,
            'OPTIONS': {
                'context_processors': [
                    'django.template.context_processors.debug',
                    'django.template.context_processors.request',
                    'django.contrib.auth.context_processors.auth',
                    'django.contrib.messages.context_processors.messages',
                ],
            },
        },
    ]

    WSGI_APPLICATION = 'hyperjob.wsgi.application'


    # Database
    # https://docs.djangoproject.com/en/2.2/ref/settings/#databases

    DATABASES = {
        'default': {
            'ENGINE': 'django.db.backends.sqlite3',
            'NAME': os.environ.get('HYPERSKILL_TEST_DATABASE') or os.path.join(BASE_DIR, 'db.sqlite3'),
        }
    }

    # Password validation
    # https://docs.djangoproject.com/en/2.2/ref/settings/#auth-password-validators

    AUTH_PASSWORD_VALIDATORS = [
        {
            'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
        },
        {
            'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
        },
        {
            'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
        },
        {
            'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
        },
    ]


    # Internationalization
    # https://docs.djangoproject.com/en/2.2/topics/i18n/

    LANGUAGE_CODE = 'en-us'

    TIME_ZONE = 'UTC'

    USE_I18N = True

    USE_L10N = True

    USE_TZ = True


    # Static files (CSS, JavaScript, Images)
    # https://docs.djangoproject.com/en/2.2/howto/static-files/

    STATIC_URL = '/static/'
  learner_created: false
- name: resume/apps.py
  visible: true
  text: |
    from django.apps import AppConfig


    class ResumeConfig(AppConfig):
        name = 'resume'
  learner_created: false
- name: resume/admin.py
  visible: true
  text: |
    from django.contrib import admin

    # Register your models here.
  learner_created: false
- name: resume/tests.py
  visible: true
  text: |
    from django.test import TestCase

    # Create your tests here.
  learner_created: false
- name: resume/views.py
  visible: true
  text: |
    from django.shortcuts import render

    # Create your views here.
  learner_created: false
- name: resume/models.py
  visible: true
  text: |
    from django.db import models

    # Create your models here.
  learner_created: false
- name: resume/migrations/__init__.py
  visible: true
  learner_created: false
- name: resume/__init__.py
  visible: true
  learner_created: false
- name: vacancy/apps.py
  visible: true
  text: |
    from django.apps import AppConfig


    class VacancyConfig(AppConfig):
        name = 'vacancy'
  learner_created: false
- name: vacancy/admin.py
  visible: true
  text: |
    from django.contrib import admin

    # Register your models here.
  learner_created: false
- name: vacancy/tests.py
  visible: true
  text: |
    from django.test import TestCase

    # Create your tests here.
  learner_created: false
- name: vacancy/views.py
  visible: true
  text: |
    from django.shortcuts import render

    # Create your views here.
  learner_created: false
- name: test/__init__.py
  visible: false
  learner_created: false
- name: manage.py
  visible: true
  text: |
    #!/usr/bin/env python
    """Django's command-line utility for administrative tasks."""
    import os
    import sys


    def main():
        os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'hyperjob.settings')
        try:
            from django.core.management import execute_from_command_line
        except ImportError as exc:
            raise ImportError(
                "Couldn't import Django. Are you sure it's installed and "
                "available on your PYTHONPATH environment variable? Did you "
                "forget to activate a virtual environment?"
            ) from exc
        execute_from_command_line(sys.argv)


    if __name__ == '__main__':
        main()
  learner_created: false
- name: tests.py
  visible: false
  text: |
    from hstest import dynamic_test

    from test.base import HyperJobTest


    class HyperJobTestRunner(HyperJobTest):

        funcs = [
            HyperJobTest.check_create_vacancies,
            HyperJobTest.check_create_resumes
        ]

        @dynamic_test(data=funcs)
        def test(self, func):
            return func(self)


    if __name__ == '__main__':
        HyperJobTestRunner().run_tests()
  learner_created: false
- name: test/base.py
  visible: false
  text: |
    import http.cookiejar
    import re
    import sqlite3
    import urllib
    import urllib.error
    import urllib.parse
    import urllib.request

    from hstest import CheckResult, DjangoTest

    INITIAL_USERS = [
        (1, 'Lemon_2059', 'contemp2015@protonmail.com', True),
        (2, 'RuthlessnessSirens-1882', 'oversured1842@yahoo.com', True),
        (3, 'moping_1935', 'tenons1970@outlook.com', True),
        (4, 'MillagePenstemon-1843', 'chrisman1923@yandex.com', True),
        (5, 'Archeus.1930', 'concentric1895@gmail.com', True),
        (6, 'BenzalazineCurite.1832', 'quassiin1927@live.com', True),
        (7, 'Bossa-1831', 'breena1977@live.com', False),
        (8, 'ClinkChinho_2027', 'adansonia1808@gmail.com', False),
        (9, 'RepassableTournefortian.1973', 'vomer1822@yahoo.com', False),
        (10, 'debenture-1898', 'average2014@yahoo.com', False),
    ]

    INITIAL_VACANCIES = [
        (1, 'Botanist'),
        (2, 'Signwriter'),
        (3, 'Stewardess'),
        (4, 'Medical Secretary'),
        (5, 'Stone Cutter'),
        (6, 'Musician'),
    ]

    INITIAL_RESUMES = [
        (7, 'Charge Hand'),
        (8, 'Occupations'),
        (9, 'Milklady'),
        (10, 'Auctioneer'),
    ]


    class HyperJobTest(DjangoTest):

        use_database = True

        USERNAME = 'Sparrow_1949'
        PASSWORD = 's<myW8Dh'
        OCCUPATION = 'Flower Arranger'

        ELEMENT_PATTERN = '''<a[^>]+href=['"](?P<href>[a-zA-Z/_]+)['"][^>]*>'''
        cookie_jar = http.cookiejar.CookieJar()

        def check_create_resume_from_profile(self) -> CheckResult:
            opener = urllib.request.build_opener(urllib.request.HTTPCookieProcessor(self.cookie_jar))
            try:
                response = opener.open(self.get_url() + 'home')
            except urllib.error.URLError:
                return CheckResult.wrong('Cannot connect to the home page.')

            csrf_options = re.findall(
                b'<input[^>]+value="(?P<csrf>\\w+)"[^>]*>', response.read()
            )
            if not csrf_options:
                return CheckResult.wrong('Missing csrf_token in the form')

            try:
                response = opener.open(
                    f'{self.get_url()}resume/new',
                    data=urllib.parse.urlencode({
                        'description': self.OCCUPATION,
                        'csrfmiddlewaretoken': csrf_options[0],
                    }).encode()
                )
            except urllib.error.URLError as err:
                return CheckResult.wrong(f'Cannot create resume: {err.reason}')

            try:
                page = self.read_page(f'{self.get_url()}resumes')
                description = f'{self.USERNAME}: {self.OCCUPATION}'
                if description not in page:
                    return CheckResult.wrong(
                        f'Resumes page does not contain newly created resume'
                    )
                return CheckResult.correct()
            except urllib.error.URLError:
                return CheckResult.wrong('Cannot connect to the resumes page.')

        def check_create_resumes(self) -> CheckResult:
            connection = sqlite3.connect(self.attach.test_database)
            cursor = connection.cursor()
            try:
                cursor.executemany(
                    'INSERT INTO auth_user '
                    '(`id`, `username`, `email`, `is_staff`, `password`, `is_superuser`, '
                    '`first_name`, `last_name`, `is_active`, `date_joined`) '
                    'VALUES (?, ?, ?, ?, "", 0, "", "", 1, datetime())',
                    INITIAL_USERS[len(INITIAL_VACANCIES):]
                )
                cursor.executemany(
                    'INSERT INTO resume_resume (`author_id`, `description`) VALUES (?, ?)',
                    INITIAL_RESUMES
                )
                connection.commit()

                cursor.execute('SELECT `author_id`, `description` FROM resume_resume')
                result = cursor.fetchall()

                for item in INITIAL_RESUMES:
                    if item not in result:
                        return CheckResult.wrong('Check your Resume model')
                return CheckResult.correct()

            except sqlite3.DatabaseError as err:
                return CheckResult.wrong(str(err))

        def check_create_vacancies(self) -> CheckResult:
            connection = sqlite3.connect(self.attach.test_database)
            cursor = connection.cursor()
            try:
                cursor.executemany(
                    'INSERT INTO auth_user '
                    '(`id`, `username`, `email`, `is_staff`, `password`, `is_superuser`, '
                    '`first_name`, `last_name`, `is_active`, `date_joined`) '
                    'VALUES (?, ?, ?, ?, "", 0, "", "", 1, datetime())',
                    INITIAL_USERS[:len(INITIAL_VACANCIES)]
                )
                cursor.executemany(
                    'INSERT INTO vacancy_vacancy (`author_id`, `description`) VALUES (?, ?)',
                    INITIAL_VACANCIES
                )
                connection.commit()

                cursor.execute('SELECT `author_id`, `description` FROM vacancy_vacancy')
                result = cursor.fetchall()

                for item in INITIAL_VACANCIES:
                    if item not in result:
                        return CheckResult.wrong('Check your Vacancy model')
                return CheckResult.correct()

            except sqlite3.DatabaseError as err:
                return CheckResult.wrong(str(err))

        def check_forbid_anonymous_create(self) -> CheckResult:
            opener = urllib.request.build_opener()
            try:
                response = opener.open(f'{self.get_url()}home')
            except urllib.error.URLError:
                return CheckResult.wrong('Cannot connect to the home page.')

            csrf_options = re.findall(
                b'<input[^>]+value="(?P<csrf>\\w+)"[^>]*>', response.read()
            )
            if not csrf_options:
                return CheckResult.correct()

            OTHER_OCCUPATION = 'Marketing Coordinator'

            try:
                response = opener.open(
                    f'{self.get_url()}resume/new',
                    data=urllib.parse.urlencode({
                        'description': OTHER_OCCUPATION,
                        'csrfmiddlewaretoken': csrf_options[0],
                    }).encode()
                )
                return CheckResult.wrong('Should not allow anonymous users create resumes')
            except urllib.error.URLError as err:
                if 'Forbidden' not in err.reason:
                    return CheckResult.wrong(f'Wrong response for forbidden requests: {err.reason}')

            try:
                page = self.read_page(f'{self.get_url()}resumes')
                if OTHER_OCCUPATION in page:
                    return CheckResult.wrong(
                        f'Resumes page should not contain resumes from anonymous users'
                    )
                return CheckResult.correct()
            except urllib.error.URLError:
                return CheckResult.wrong('Cannot connect to the resumes page.')

        def check_forbid_to_create_vacancy(self) -> CheckResult:
            opener = urllib.request.build_opener(urllib.request.HTTPCookieProcessor(self.cookie_jar))
            try:
                response = opener.open(f'{self.get_url()}home')
            except urllib.error.URLError:
                return CheckResult.wrong('Cannot connect to the home page.')

            csrf_options = re.findall(
                b'<input[^>]+value="(?P<csrf>\\w+)"[^>]*>', response.read()
            )
            if not csrf_options:
                return CheckResult.correct()

            OTHER_OCCUPATION = 'Marketing Coordinator'

            try:
                response = opener.open(
                    f'{self.get_url()}vacancy/new',
                    data=urllib.parse.urlencode({
                        'description': OTHER_OCCUPATION,
                        'csrfmiddlewaretoken': csrf_options[0],
                    }).encode()
                )
                return CheckResult.wrong('Should not allow usual users create vacancies')
            except urllib.error.URLError as err:
                if 'Forbidden' not in err.reason:
                    return CheckResult.wrong(f'Wrong response for forbidden requests: {err.reason}')

            try:
                page = self.read_page(f'{self.get_url()}vacancies')
                if OTHER_OCCUPATION in page:
                    return CheckResult.wrong(
                        f'Vacancies page should not contain vacancies from usual users'
                    )
                return CheckResult.correct()
            except urllib.error.URLError:
                return CheckResult.wrong('Cannot connect to the vacancies page.')

        def check_greeting(self) -> CheckResult:
            try:
                main_page = self.read_page(self.get_url())
                if 'Welcome to HyperJob!' in main_page:
                    return CheckResult.correct()
                return CheckResult.wrong(
                    'Main page should contain "Welcome to HyperJob!" line'
                )
            except urllib.error.URLError:
                return CheckResult.wrong(
                    'Cannot connect to the menu page.'
                )

        def check_links(self) -> CheckResult:
            try:
                page = self.read_page(self.get_url())
                links = re.findall(self.ELEMENT_PATTERN, page)
                for link in (
                    '/login',
                    '/signup',
                    '/vacancies',
                    '/resumes',
                    '/home',
                ):
                    if link not in links:
                        return CheckResult.wrong(
                            f'Menu page should contain <a> element with href {link}'
                        )
                return CheckResult.correct()
            except urllib.error.URLError:
                return CheckResult.wrong(
                    'Cannot connect to the menu page.'
                )

        def check_login(self) -> CheckResult:
            opener = urllib.request.build_opener(urllib.request.HTTPCookieProcessor(self.cookie_jar))
            try:
                response = opener.open(f'{self.get_url()}login')
            except urllib.error.URLError:
                return CheckResult.wrong('Cannot connect to the login page.')

            csrf_options = re.findall(
                b'<input[^>]+value="(?P<csrf>\\w+)"[^>]*>', response.read()
            )
            if not csrf_options:
                return CheckResult.wrong('Missing csrf_token in the form')

            try:
                response = opener.open(
                    f'{self.get_url()}login',
                    data=urllib.parse.urlencode({
                        'csrfmiddlewaretoken': csrf_options[0],
                        'username': self.USERNAME,
                        'password': self.PASSWORD,
                    }).encode()
                )
                if 'login' not in response.url:
                    return CheckResult.correct()
                return CheckResult.wrong('Cannot login: problems with form')
            except urllib.error.URLError as err:
                return CheckResult.wrong(f'Cannot login: {err.reason}')

        def check_resumes(self) -> CheckResult:
            try:
                page = self.read_page(f'{self.get_url()}resumes')
                for person, resume in zip(INITIAL_USERS[len(INITIAL_VACANCIES):], INITIAL_RESUMES):
                    description = f'{person[1]}: {resume[1]}'
                    if description not in page:
                        return CheckResult.wrong(
                            f'Resumes page should contain resumes in form <username>: <description>'
                        )
                return CheckResult.correct()
            except urllib.error.URLError:
                return CheckResult.wrong(
                    'Cannot connect to the resumes page.'
                )

        def check_signup(self) -> CheckResult:
            opener = urllib.request.build_opener(
                urllib.request.HTTPCookieProcessor(self.cookie_jar)
            )
            try:
                response = opener.open(f'{self.get_url()}signup')
            except urllib.error.URLError:
                return CheckResult.wrong('Cannot connect to the signup page.')

            csrf_options = re.findall(
                b'<input[^>]+value="(?P<csrf>\\w+)"[^>]*>', response.read()
            )
            if not csrf_options:
                return CheckResult.wrong('Missing csrf_token in the form')

            try:
                response = opener.open(
                    f'{self.get_url()}signup',
                    data=urllib.parse.urlencode({
                        'csrfmiddlewaretoken': csrf_options[0],
                        'username': self.USERNAME,
                        'password1': self.PASSWORD,
                        'password2': self.PASSWORD,
                    }).encode()
                )
                if f'login' in response.url:
                    return CheckResult.correct()
                return CheckResult.wrong('Cannot signup: problems with form')
            except urllib.error.URLError as err:
                return CheckResult.wrong(f'Cannot signup: {err.reason}')

        def check_vacancies(self) -> CheckResult:
            try:
                page = self.read_page(f'{self.get_url()}vacancies')
                for person, vacancy in zip(INITIAL_USERS, INITIAL_VACANCIES):
                    description = f'{person[1]}: {vacancy[1]}'
                    if description not in page:
                        return CheckResult.wrong(
                            f'Vacancies page should contain vacancies in form <username>: <description>'
                        )
                return CheckResult.correct()
            except urllib.error.URLError:
                return CheckResult.wrong(
                    'Cannot connect to the vacancies page.'
                )
  learner_created: false
- name: vacancy/models.py
  visible: true
  text: |
    from django.db import models

    # Create your models here.
  learner_created: false
- name: db.sqlite3
  visible: true
  learner_created: true
- name: resume/migrations/0001_initial.py
  visible: true
  learner_created: true
- name: vacancy/migrations/0001_initial.py
  visible: true
  learner_created: true
feedback_link: https://hyperskill.org/projects/94/stages/519/implement#comment
status: Solved
feedback:
  message: Congratulations!
  time: Tue, 25 May 2021 05:28:11 UTC
record: 1
