type: edu
custom_name: stage4
files:
- name: hypercar/hypercar/wsgi.py
  visible: true
  text: |
    """
    WSGI config for hypercar project.

    It exposes the WSGI callable as a module-level variable named ``application``.

    For more information on this file, see
    https://docs.djangoproject.com/en/2.2/howto/deployment/wsgi/
    """

    import os

    from django.core.wsgi import get_wsgi_application

    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'hypercar.settings')

    application = get_wsgi_application()
  learner_created: false
- name: hypercar/hypercar/__init__.py
  visible: true
  learner_created: false
- name: hypercar/hypercar/settings.py
  visible: true
  text: |
    """
    Django settings for hypercar project.

    Generated by 'django-admin startproject' using Django 2.2.6.

    For more information on this file, see
    https://docs.djangoproject.com/en/2.2/topics/settings/

    For the full list of settings and their values, see
    https://docs.djangoproject.com/en/2.2/ref/settings/
    """

    import os

    # Build paths inside the project like this: os.path.join(BASE_DIR, ...)
    BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))


    # Quick-start development settings - unsuitable for production
    # See https://docs.djangoproject.com/en/2.2/howto/deployment/checklist/

    # SECURITY WARNING: keep the secret key used in production secret!
    SECRET_KEY = '_^m1$hfk6a^^)zbdize#nwxya@kc9q^@$kzpzzwz!_+l#(5y0%'

    # SECURITY WARNING: don't run with debug turned on in production!
    DEBUG = True

    ALLOWED_HOSTS = []


    # Application definition

    INSTALLED_APPS = [
        'django.contrib.admin',
        'django.contrib.auth',
        'django.contrib.contenttypes',
        'django.contrib.sessions',
        'django.contrib.messages',
        'django.contrib.staticfiles',
        'tickets',
    ]

    MIDDLEWARE = [
        'django.middleware.security.SecurityMiddleware',
        'django.contrib.sessions.middleware.SessionMiddleware',
        'django.middleware.common.CommonMiddleware',
        'django.middleware.csrf.CsrfViewMiddleware',
        'django.contrib.auth.middleware.AuthenticationMiddleware',
        'django.contrib.messages.middleware.MessageMiddleware',
        'django.middleware.clickjacking.XFrameOptionsMiddleware',
    ]

    ROOT_URLCONF = 'hypercar.urls'

    TEMPLATES = [
        {
            'BACKEND': 'django.template.backends.django.DjangoTemplates',
            'DIRS': [],
            'APP_DIRS': True,
            'OPTIONS': {
                'context_processors': [
                    'django.template.context_processors.debug',
                    'django.template.context_processors.request',
                    'django.contrib.auth.context_processors.auth',
                    'django.contrib.messages.context_processors.messages',
                ],
            },
        },
    ]

    WSGI_APPLICATION = 'hypercar.wsgi.application'


    # Database
    # https://docs.djangoproject.com/en/2.2/ref/settings/#databases

    DATABASES = {
        'default': {
            'ENGINE': 'django.db.backends.sqlite3',
            'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),
        }
    }


    # Password validation
    # https://docs.djangoproject.com/en/2.2/ref/settings/#auth-password-validators

    AUTH_PASSWORD_VALIDATORS = [
        {
            'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
        },
        {
            'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
        },
        {
            'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
        },
        {
            'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
        },
    ]


    # Internationalization
    # https://docs.djangoproject.com/en/2.2/topics/i18n/

    LANGUAGE_CODE = 'en-us'

    TIME_ZONE = 'UTC'

    USE_I18N = True

    USE_L10N = True

    USE_TZ = True


    # Static files (CSS, JavaScript, Images)
    # https://docs.djangoproject.com/en/2.2/howto/static-files/

    STATIC_URL = '/static/'
  learner_created: false
- name: hypercar/manage.py
  visible: true
  text: |
    #!/usr/bin/env python
    """Django's command-line utility for administrative tasks."""
    import os
    import sys


    def main():
        os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'hypercar.settings')
        try:
            from django.core.management import execute_from_command_line
        except ImportError as exc:
            raise ImportError(
                "Couldn't import Django. Are you sure it's installed and "
                "available on your PYTHONPATH environment variable? Did you "
                "forget to activate a virtual environment?"
            ) from exc
        execute_from_command_line(sys.argv)


    if __name__ == '__main__':
        main()
  learner_created: false
- name: hypercar/tickets/apps.py
  visible: true
  text: |
    from django.apps import AppConfig


    class TicketsConfig(AppConfig):
        name = 'tickets'
  learner_created: false
- name: hypercar/tickets/admin.py
  visible: true
  text: |
    from django.contrib import admin

    # Register your models here.
  learner_created: false
- name: hypercar/tickets/tests.py
  visible: true
  text: |
    from django.test import TestCase

    # Create your tests here.
  learner_created: false
- name: hypercar/tickets/models.py
  visible: true
  text: |
    from django.db import models

    # Create your models here.
  learner_created: false
- name: hypercar/tickets/migrations/__init__.py
  visible: true
  learner_created: false
- name: tests.py
  visible: false
  text: |
    from functools import partial
    from urllib.error import URLError
    from urllib.request import urlopen
    from hstest.check_result import CheckResult
    from hstest.test_case import TestCase
    from hstest.django_test import DjangoTest


    class HypercarOperatorMenuTest(DjangoTest):

        def get_ticket(self, service: str, content: str, helper_msg: str) -> CheckResult:
            try:
                page = self.read_page(f'http://localhost:{self.port}/get_ticket/{service}')
                if content in page:
                    return CheckResult.true()
                else:
                    return CheckResult.false(
                        f'Expected to have {content} on /get_ticket/{service} page after\n'
                        f'{helper_msg}'
                    )
            except URLError:
                return CheckResult.false(
                    f'Cannot connect to the /get_ticket/{service} page.'
                )

        def check_menu(self, service: str, content: str, menu_content: str,
                       helper_msg: str) -> CheckResult:
            try:
                result = self.get_ticket(service, content, helper_msg)
                if not result.result:
                    return result

                page = self.read_page(f'http://localhost:{self.port}/processing')
                if menu_content in page:
                    return CheckResult.true()
                else:
                    return CheckResult.false(
                        f'Expected to have {menu_content} on /processing page after\n'
                        f'{helper_msg}'
                    )
            except URLError:
                return CheckResult.false(
                    f'Cannot connect to the /processing page.'
                )

        def generate(self):
            helper_msg_1 = '\tClient #1 get ticket for inflating tires\n'
            helper_msg_2 = helper_msg_1 + '\tClient #2 get ticket for changing oil\n'
            helper_msg_3 = helper_msg_2 + '\tClient #3 get ticket for changing oil\n'
            helper_msg_4 = helper_msg_3 + '\tClient #4 get ticket for inflating tires\n'
            helper_msg_5 = helper_msg_4 + '\tClient #5 get ticket for diagnostic\n'
            return [
                TestCase(attach=self.check_server),
                TestCase(attach=partial(
                    self.check_menu,
                    'inflate_tires',
                    'Please wait around 0 minutes',
                    'Inflate tires queue: 1',
                    helper_msg_1
                )),
                TestCase(attach=partial(
                    self.check_menu,
                    'change_oil',
                    'Please wait around 0 minutes',
                    'Change oil queue: 1',
                    helper_msg_2
                )),
                TestCase(attach=partial(
                    self.check_menu,
                    'change_oil',
                    'Please wait around 2 minutes',
                    'Change oil queue: 2',
                    helper_msg_3
                )),
                TestCase(attach=partial(
                    self.check_menu,
                    'inflate_tires',
                    'Please wait around 9 minutes',
                    'Inflate tires queue: 2',
                    helper_msg_4
                )),
                TestCase(attach=partial(
                    self.check_menu,
                    'diagnostic',
                    'Please wait around 14 minutes',
                    'Get diagnostic queue: 1',
                    helper_msg_5
                )),
            ]

        def check(self, reply, attach):
            return attach()


    if __name__ == '__main__':
        HypercarOperatorMenuTest('hypercar.manage').run_tests()
  learner_created: false
- name: hstest/check_result.py
  visible: false
  text: |
    class CheckResult:

        def __init__(self, result: bool, feedback: str):
            self.result = result
            self.feedback = feedback

        @staticmethod
        def true():
            return CheckResult(True, '')

        @staticmethod
        def false(feedback: str = ''):
            return CheckResult(False, feedback)


    def wrong(feedback: str = '') -> CheckResult:
        return CheckResult.false(feedback)


    def accept():
        return CheckResult.true()
  learner_created: false
- name: hstest/django_test.py
  visible: false
  text: |
    import os
    import sys
    import signal
    import subprocess
    from time import sleep
    from urllib.error import URLError, HTTPError
    from urllib.request import urlopen
    from hstest.stage_test import StageTest
    from hstest.check_result import CheckResult


    class DjangoTest(StageTest):

        _kill = os.kill
        port = '0'
        tryout_ports = ['8000', '8001', '8002', '8003', '8004']
        process = None

        def run(self):
            if self.process is None:
                self.__find_free_port()
                self.process = subprocess.Popen([
                    sys.executable, self.file_to_test,
                    'runserver', self.port, '--noreload',
                ])

        def check_server(self):
            if self.port == '0':
                return CheckResult.false(
                    f'Please free one of the ports: {", ".join(self.tryout_ports)}'
                )

            for _ in range(15):
                try:
                    urlopen(f'http://localhost:{self.port}/not-existing-link-by-default')
                    return CheckResult.true()
                except URLError as err:
                    if isinstance(err, HTTPError):
                        return CheckResult.true()
                    sleep(1)
            else:
                return CheckResult.false(
                    'Cannot start the ./manage.py runserver for 15 seconds'
                )

        def __find_free_port(self):
            for port in self.tryout_ports:
                try:
                    urlopen(f'http://localhost:{port}')
                except URLError as err:
                    if isinstance(err.reason, ConnectionRefusedError):
                        self.port = port
                        break

        def read_page(self, link: str) -> str:
            return urlopen(link).read().decode().replace('\u00a0', ' ')

        def after_all_tests(self):
            if self.process is not None:
                try:
                    self._kill(self.process.pid, signal.SIGINT)
                except ProcessLookupError:
                    pass
  learner_created: false
- name: hstest/exceptions.py
  visible: false
  text: |2

    class BadSolutionException(Exception):
        def __init__(self, message):
            self.message = message


    class SyntaxException(BadSolutionException):
        def __init__(self, message):
            super().__init__(message)


    class ExitException(BadSolutionException):
        def __init__(self, message):
            super().__init__(message)
  learner_created: false
- name: hstest/stage_test.py
  visible: false
  text: |
    import sys
    import runpy
    import os
    import io
    import importlib
    import signal
    import builtins
    import traceback
    from typing import List, Any, Dict
    from hstest.test_helper import *
    from hstest.test_case import TestCase
    from hstest.check_result import CheckResult
    from hstest.exceptions import *


    class StageTest:

        real_stdin = None
        real_print = None
        real_input = None
        user_output: io.StringIO = None

        @staticmethod
        def remove_kill_methods():
            os.kill = lambda *x, **y: exit(0)
            os._exit = lambda *x, **y: exit(0)
            os.killpg = lambda *x, **y: exit(0)
            signal.pthread_kill = lambda *x, **y: exit(0)
            signal.siginterrupt = lambda *x, **y: exit(0)

        @staticmethod
        def set_input(user_input: str):
            sys.stdin = io.StringIO(user_input)

        @staticmethod
        def add_input(user_input: str):
            sys.stdin: io.StringIO
            curr_position = sys.stdin.seek(0, io.SEEK_CUR)
            sys.stdin.seek(0)
            sys.stdin = io.StringIO(sys.stdin.read() + user_input)
            sys.stdin.seek(curr_position)

        @staticmethod
        def print(*args, **kwargs):
            StageTest.real_print(*args, **kwargs)
            StageTest.real_print(*args, **kwargs, file=StageTest.user_output)

        @staticmethod
        def input(arg=''):
            StageTest.print(arg, end='')
            user_input = StageTest.real_input()
            # StageTest.print()
            return user_input

        @staticmethod
        def replace_globals():
            StageTest.real_stdin = sys.stdin
            StageTest.real_print = builtins.print
            StageTest.real_input = builtins.input
            builtins.print = StageTest.print
            builtins.input = StageTest.input

        @staticmethod
        def get_print_back():
            builtins.print = StageTest.real_print
            sys.stdin = StageTest.real_stdin

        def __init__(self, module_to_test: str):
            self.remove_kill_methods()
            self.replace_globals()
            self.module_to_test = module_to_test
            self.this_test_file = __file__
            self.file_to_test = module_to_test.replace('.', os.sep) + '.py'
            self.full_file_to_test = ''
            self.tests: List[TestCase] = []

        def reset(self):
            StageTest.user_output = io.StringIO()
            top_module = self.module_to_test[:self.module_to_test.index('.')]
            for name, module in list(sys.modules.items()):
                if name.startswith(top_module):
                    importlib.reload(module)

        @staticmethod
        def create_files(files: Dict[str, str]):
            for file, content in files.items():
                with open(file, 'w') as f:
                    f.write(content)

        @staticmethod
        def delete_files(files: Dict[str, str]):
            for file in files.keys():
                if os.path.isfile(file):
                    os.remove(file)

        def run(self):
            runpy.run_module(
                self.module_to_test,
                run_name="__main__"
            )

        def test(self, test_case: TestCase) -> str:
            self.reset()
            try:
                self.create_files(test_case.files)
                sys.argv = [self.file_to_test] + test_case.args
                self.set_input(test_case.input)
                self.run()
                self.delete_files(test_case.files)
                return StageTest.user_output.getvalue()

            except SyntaxError as e:

                file = e.filename
                file = file.replace(os.sep, '.')
                file = file[file.index(self.module_to_test):-3]
                file = file.replace('.', os.sep) + '.py'

                output = f'File "{file}", line {e.lineno}\n' \
                         + e.text.strip()[: e.offset-1] + '\n' \
                         'SyntaxError: invalid syntax'

                # '`' * (e.offset - 2) + '^'

                raise SyntaxException(output)

            except (SystemExit, KeyboardInterrupt):
                raise ExitException('Tried to exit.')

        def generate(self) -> List[TestCase]:
            raise NotImplemented

        def check(self, reply: str, attach: Any) -> CheckResult:
            raise NotImplemented

        def after_all_tests(self):
            pass

        def get_stacktrace(self, hide_internals, skipped_traces=0):

            if self.full_file_to_test != '':
                common_prefix = os.path.commonpath([
                    self.full_file_to_test, self.this_test_file
                ])
            else:
                common_prefix = ''

            exc_type, exc_obj, exc_tb = sys.exc_info()

            if hide_internals and skipped_traces != 0:
                traceback_msg = 'Traceback (most recent call last):\n'
            else:
                traceback_msg = ''

            for line in traceback.TracebackException(
                    type(exc_obj), exc_obj, exc_tb, limit=None).format(chain=None):
                if not hide_internals:
                    traceback_msg += line
                elif skipped_traces >= 0:
                    skipped_traces -= 1
                elif self.this_test_file not in line:
                    traceback_msg += line.replace(common_prefix + os.sep, '')

            return traceback_msg

        def run_tests(self):

            test_number = 0
            try:
                for test in self.generate():
                    test_number += 1
                    reply = self.test(test)
                    result = self.check(reply, test.attach)
                    if not result.result:
                        fail_msg = f'Wrong answer in test #{test_number}'
                        self.get_print_back()
                        failed(fail_msg + '\n\n' + result.feedback)
                        break
                passed()

            except SyntaxException as ex:
                self.get_print_back()
                failed(ex.message)

            except ExitException as ex:
                error_msg = f'Error in test #{test_number}'
                self.get_print_back()
                failed(error_msg + '\n\n' + ex.message)

            except Exception:

                exc_type, exc_obj, exc_tb = sys.exc_info()
                trace_frames = []

                user_trace_started = False
                skipped_traces = 0
                while exc_tb is not None:
                    code = exc_tb.tb_frame.f_code
                    filename = code.co_filename

                    if filename.endswith(self.file_to_test) and not user_trace_started:
                        user_trace_started = True
                        self.full_file_to_test = exc_tb.tb_frame.f_code.co_filename

                    if user_trace_started:
                        trace_frames += [exc_tb.tb_frame.f_code]
                    else:
                        skipped_traces += 1

                    exc_tb = exc_tb.tb_next

                if not trace_frames:
                    exception_msg = (
                            f"Fatal error in test #{test_number}, " +
                            "please send the report to support@hyperskill.org"
                    )
                    stacktrace = self.get_stacktrace(hide_internals=False)

                else:
                    exception_msg = f'Exception in test #{test_number}'
                    stacktrace = self.get_stacktrace(
                        hide_internals=True,
                        skipped_traces=skipped_traces
                    )

                self.get_print_back()
                failed(exception_msg + '\n\n' + stacktrace)
            finally:
                self.after_all_tests()
  learner_created: false
- name: hstest/test_case.py
  visible: false
  text: |
    from typing import List, Dict, Any, Tuple, Callable


    class TestCase:

        def __init__(self, *, stdin='', args=None,
                     attach=None, files=None, copy_to_attach=False,
                     attach_callback=None):
            self.input: str = stdin
            self.args: List[str] = [] if args is None else args
            self.attach: Any = attach
            self.attach_callback: Callable = attach_callback
            self.files: Dict[str, str] = {} if files is None else files
            if copy_to_attach:
                self.attach = stdin

        @staticmethod
        def from_stepik(stepik_tests: List[Tuple[str, Any]]) -> List['TestCase']:
            hs_tests = []
            for test in stepik_tests:
                hs_test = TestCase()
                if type(test) in (list, tuple):
                    hs_test.input = test[0]
                    hs_test.attach = test[1]
                elif type(test) is str:
                    hs_test.input = test
                else:
                    raise ValueError("Bad test: " + str(test))
                hs_tests += [hs_test]
            return hs_tests
  learner_created: false
- name: hstest/test_helper.py
  visible: false
  text: |2

    def set_congratulation_message(message):
        """ Overrides default 'Congratulations!' message """
        print("#educational_plugin CONGRATS_MESSAGE " + message)


    def failed(message: str):
        """ Reports failure """
        lines = message.splitlines()
        print("\n#educational_plugin FAILED + " + lines[0])
        for line in lines[1:]:
            print("#educational_plugin " + line)


    def passed():
        """ Reports success """
        print("#educational_plugin test OK")
  learner_created: false
- name: hypercar/tickets/templates/base.html
  visible: true
  text: |-
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>{% block title %}Hyper Cars{% endblock %}</title>
    </head>
    <body>
        {% block content %}{% endblock %}
    </body>
    </html>
  learner_created: true
- name: hypercar/tickets/templates/ticket.html
  visible: true
  text: |-
    {% extends 'base.html' %}

    {% block title %}{{ block.super }}{% endblock %}

    {% block content %}
        <div>Your number is {{ num_ticket }}</div>
        <div>Please wait around {{ mins }} minutes</div>
    {% endblock %}
  learner_created: true
- name: hypercar/tickets/templates/menu.html
  visible: true
  text: |-
    {% extends 'base.html' %}

    {% block title %}{{ block.super }}{% endblock %}

    {% block content %}
        <a target="_blank" href="/get_ticket/change_oil">Change oil</a>
        <br>
        <a target="_blank" href="/get_ticket/inflate_tires">Inflate tires</a>
        <br>
        <a target="_blank" href="/get_ticket/diagnostic">Diagnostic</a>
    {% endblock %}
  learner_created: true
- name: hypercar/hypercar/urls.py
  visible: true
  text: |
    """hypercar URL Configuration

    The `urlpatterns` list routes URLs to views. For more information please see:
        https://docs.djangoproject.com/en/2.2/topics/http/urls/
    Examples:
    Function views
        1. Add an import:  from my_app import views
        2. Add a URL to urlpatterns:  path('', views.home, name='home')
    Class-based views
        1. Add an import:  from other_app.views import Home
        2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
    Including another URLconf
        1. Import the include() function: from django.urls import include, path
        2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
    """
    from django.urls import path
    from tickets.views import WelcomeView


    urlpatterns = [
        path('welcome/', WelcomeView.as_view()),
    ]
  learner_created: false
- name: hypercar/tickets/views.py
  visible: true
  text: |
    from django.views import View
    from django.http.response import HttpResponse


    class WelcomeView(View):
        def get(self, request, *args, **kwargs):
            return HttpResponse('<h2>Welcome to the Hypercar Service!</h2>')
  learner_created: false
- name: hypercar/tickets/__init__.py
  visible: true
  learner_created: false
- name: hypercar/tickets/templates/processing.html
  visible: true
  learner_created: true
feedback_link: https://hyperskill.org/projects/85/stages/473/implement#comment
status: Solved
feedback:
  message: Congratulations!
  time: Fri, 28 May 2021 15:46:04 UTC
record: 4
